---
description: Modern React 19 patterns and performance best practices for Korean trade platform
globs: 
alwaysApply: true
---

# Modern React Patterns & Performance Guide

## Core React 19 Principles

### New Hooks & Patterns
- **TanStack Query integration** - recommended for server state management
- **TanStack Router file-based routing** - type-safe navigation patterns
- **TanStack Query `use()` hook** - experimental React 19 compatible API
- **React 19 `use()` for context** - consume React context without useContext
- **Refs as props** - no more forwardRef needed, pass refs like regular props
- **Actions pattern** - leverage React 19's built-in form actions
- **Automatic optimizations** - React Compiler will handle most memoization (when available)

### TanStack Router Patterns

**File-based Routing Structure:**
```typescript
// routes/__root.tsx - Root layout
export const Route = createRootRoute({
  component: RootComponent,
});

// routes/index.tsx - Home page  
export const Route = createFileRoute('/')({
  component: HomePage,
});

// routes/hscode/$hsCode.tsx - Dynamic route
export const Route = createFileRoute('/hscode/$hsCode')({
  component: HSCodeDetail,
  loader: ({ params }) => queryClient.ensureQueryData({
    queryKey: ['hscode', params.hsCode],
    queryFn: () => api.getHSCodeInfo(params.hsCode),
  }),
});
```

**Type-safe Navigation:**
```typescript
// ğŸ¯ Recommended: Type-safe navigation with search params
const navigate = useNavigate();

const handleSearch = (query: string) => {
  navigate({ 
    to: '/search', 
    search: { q: query, filters: selectedFilters } 
  });
};

// ğŸ¯ Route-specific hooks for params and search
const { hsCode } = Route.useParams(); // Type-safe params
const { q, filters } = Route.useSearch(); // Type-safe search params
```

**Router + TanStack Query Integration:**
```typescript
// ğŸ¯ Recommended: Prefetch data in route loaders
export const Route = createFileRoute('/analysis/$sessionId')({
  component: AnalysisPage,
  loader: async ({ params }) => {
    // Prefetch data before component renders
    await queryClient.ensureQueryData({
      queryKey: ['analysisSession', params.sessionId],
      queryFn: () => claudeApi.getAnalysisSession(params.sessionId),
    });
  },
  pendingComponent: () => <AnalysisSpinner />,
  errorComponent: ({ error }) => <ErrorDisplay error={error} />,
});
```

### Performance Optimization Guidelines

#### Memoization Recommendations (Until React Compiler)
Consider these patterns when optimizing performance:

**useCallback - Function Memoization:**
```typescript
// ğŸ¯ Consider when passing callbacks to optimized child components
const handleSubmit = useCallback((data: FormData) => {
  // Logic here
}, [dependency1, dependency2]);

// ğŸ’¡ Alternative: Simple functions often don't need memoization
const simpleHandler = () => console.log('click'); // Usually fine as-is
```

**useMemo - Value Memoization:**
```typescript
// ğŸ¯ Recommended for expensive calculations
const expensiveValue = useMemo(() => {
  return heavyComputation(data);
}, [data]);

// ğŸ¯ Consider for object/array references passed to children
const config = useMemo(() => ({
  apiKey: process.env.API_KEY,
  baseUrl: '/api/v1'
}), []);

// ğŸ’¡ Note: Primitive values rarely need memoization
const simpleValue = data.length; // Memoization usually unnecessary
```

#### useEffect Best Practices (Client State & Side Effects)

**When to Use useEffect (Not for Server Data):**
```typescript
// âœ… DOM manipulation and browser APIs
useEffect(() => {
  document.title = `ë¶„ì„ ê²°ê³¼: ${hsCode}`;
}, [hsCode]);

// âœ… Event listeners and cleanup
useEffect(() => {
  const handleKeyPress = (e: KeyboardEvent) => {
    if (e.key === 'Escape') closeModal();
  };
  
  window.addEventListener('keydown', handleKeyPress);
  return () => window.removeEventListener('keydown', handleKeyPress);
}, []);

// âœ… Local storage synchronization
useEffect(() => {
  localStorage.setItem('userPreferences', JSON.stringify(preferences));
}, [preferences]);

// âœ… WebSocket connections (not for REST API calls)
useEffect(() => {
  const ws = new WebSocket('/api/monitoring');
  ws.onmessage = (event) => {
    setRealTimeUpdates(JSON.parse(event.data));
  };
  
  return () => ws.close();
}, []);

// âŒ Don't use for server data fetching (use TanStack Query)
useEffect(() => {
  fetch('/api/data').then(r => r.json()).then(setData); // Wrong!
}, []);
```

**Server State vs Client State Separation:**
```typescript
// âœ… Server State - Use TanStack Query
const { data: hsCodeData } = useQuery({
  queryKey: ['hscode', code],
  queryFn: () => api.getHSCodeInfo(code),
});

// âœ… Client State - Use useState + useEffect if needed
const [selectedTab, setSelectedTab] = useState('basic');
const [isModalOpen, setIsModalOpen] = useState(false);

useEffect(() => {
  // Client-side logic only
  if (isModalOpen) {
    document.body.style.overflow = 'hidden';
    return () => { document.body.style.overflow = 'unset'; };
  }
}, [isModalOpen]);
```

**Data Fetching Patterns with TanStack Query:**
```typescript
// âœ… TanStack Query - Preferred approach for server state
const { data, isLoading, error } = useQuery({
  queryKey: ['hsCodeAnalysis', query],
  queryFn: () => claudeApi.analyzeHSCode(query),
  enabled: !!query, // Only run when query exists
  staleTime: 5 * 60 * 1000, // 5 minutes
  gcTime: 10 * 60 * 1000, // 10 minutes
});

// âœ… TanStack Query Suspense approach
const { data } = useSuspenseQuery({
  queryKey: ['cargoTracking', cargoNumber],
  queryFn: () => customsApi.trackCargo(cargoNumber),
});

// âœ… TanStack Query use() hook (experimental - React 19 compatible)
import { use } from '@tanstack/react-query';

const query = use({
  queryKey: ['tradeStatistics', hsCode],
  queryFn: () => comtradeApi.getStatistics(hsCode),
});

// âŒ Avoid manual useEffect for server data
const [data, setData] = useState(null);
useEffect(() => {
  // Don't manage server state manually
  fetchData().then(setData);
}, []);
```

## State Management with Zustand

### Store Design Patterns

**Domain-separated Stores:**
```typescript
// ğŸ¯ Recommended: Separate stores by domain
type AuthStore = {
  user: User | null;
  isLoading: boolean;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
};

export const useAuthStore = create<AuthStore>((set, get) => ({
  user: null,
  isLoading: false,
  login: async (credentials) => {
    set({ isLoading: true });
    try {
      const user = await authApi.login(credentials);
      set({ user, isLoading: false });
    } catch (error) {
      set({ isLoading: false });
      throw error;
    }
  },
  logout: () => set({ user: null }),
}));

// ğŸ¯ Consider: Separate UI state from business logic
type UIStore = {
  sidebarOpen: boolean;
  currentTheme: 'light' | 'dark';
  toggleSidebar: () => void;
  setTheme: (theme: 'light' | 'dark') => void;
};

export const useUIStore = create<UIStore>((set) => ({
  sidebarOpen: false,
  currentTheme: 'light',
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
  setTheme: (theme) => set({ currentTheme: theme }),
}));
```

**Store Integration with TanStack Query:**
```typescript
// ğŸ¯ Recommended: Zustand for client state, TanStack Query for server state
const useBookmarkStore = create<BookmarkStore>((set, get) => ({
  selectedFilters: [],
  sortOrder: 'recent',
  
  // Client state actions
  setFilters: (filters) => set({ selectedFilters: filters }),
  setSortOrder: (order) => set({ sortOrder: order }),
  
  // ğŸ’¡ Note: Server operations delegated to TanStack Query
  // Don't put server data directly in Zustand stores
}));

// Component usage
const BookmarkList = () => {
  // Server state from TanStack Query
  const { data: bookmarks } = useQuery({
    queryKey: ['bookmarks'],
    queryFn: () => api.getBookmarks(),
  });
  
  // Client state from Zustand
  const { selectedFilters, setFilters } = useBookmarkStore();
  
  const filteredBookmarks = useMemo(() => 
    bookmarks?.filter(bookmark => 
      selectedFilters.every(filter => bookmark.tags.includes(filter))
    ), [bookmarks, selectedFilters]
  );
  
  return <BookmarkGrid bookmarks={filteredBookmarks} />;
};
```

**Cross-Store Communication:**
```typescript
// ğŸ¯ Consider: Explicit cross-store dependencies
type NotificationStore = {
  notifications: Notification[];
  addNotification: (notification: Omit<Notification, 'id'>) => void;
  removeNotification: (id: string) => void;
};

export const useNotificationStore = create<NotificationStore>((set) => ({
  notifications: [],
  addNotification: (notification) => {
    const id = crypto.randomUUID();
    set((state) => ({
      notifications: [...state.notifications, { ...notification, id }],
    }));
  },
  removeNotification: (id) => 
    set((state) => ({
      notifications: state.notifications.filter(n => n.id !== id),
    })),
}));

// Usage in auth store
const useAuthStore = create<AuthStore>((set, get) => ({
  login: async (credentials) => {
    try {
      // ... login logic
      useNotificationStore.getState().addNotification({
        type: 'success',
        message: 'ë¡œê·¸ì¸ë˜ì—ˆìŠµë‹ˆë‹¤.',
      });
    } catch (error) {
      // Handle error
    }
  },
}));
```

## Form Handling with React Hook Form + Zod

### Validation Patterns

**Schema-first Approach:**
```typescript
// ğŸ¯ Recommended: Define schemas separately for reusability
const hsCodeSearchSchema = z.object({
  query: z.string().min(1, 'ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”'),
  category: z.enum(['all', 'electronics', 'textiles']).optional(),
  country: z.string().optional(),
});

type HSCodeSearchForm = z.infer<typeof hsCodeSearchSchema>;

// Component usage
const HSCodeSearchForm = () => {
  const { register, handleSubmit, formState: { errors } } = useForm<HSCodeSearchForm>({
    resolver: zodResolver(hsCodeSearchSchema),
    defaultValues: {
      query: '',
      category: 'all',
    },
  });

  const searchMutation = useMutation({
    mutationFn: (data: HSCodeSearchForm) => claudeApi.analyzeHSCode(data),
    onSuccess: (result) => {
      // Navigate to results
      navigate({ to: '/analysis/$sessionId', params: { sessionId: result.sessionId } });
    },
  });

  const onSubmit = (data: HSCodeSearchForm) => {
    searchMutation.mutate(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label htmlFor="query">ìƒí’ˆëª… ë˜ëŠ” ì„¤ëª…</label>
        <input
          id="query"
          {...register('query')}
          placeholder="ì˜ˆ: ì•„ì´í° 15"
        />
        {errors.query && <span className="error">{errors.query.message}</span>}
      </div>
      
      <button type="submit" disabled={searchMutation.isPending}>
        {searchMutation.isPending ? 'ë¶„ì„ ì¤‘...' : 'HS Code ë¶„ì„'}
      </button>
    </form>
  );
};
```

**Complex Form Patterns:**
```typescript
// ğŸ¯ Consider: Nested objects and arrays
const userPreferencesSchema = z.object({
  profile: z.object({
    name: z.string().min(2),
    email: z.string().email(),
  }),
  notifications: z.object({
    email: z.boolean(),
    push: z.boolean(),
  }),
  bookmarkCategories: z.array(z.string()).min(1, 'ìµœì†Œ í•˜ë‚˜ì˜ ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”'),
});

// ğŸ’¡ Alternative: Field arrays for dynamic forms
const monitoringSetupSchema = z.object({
  targets: z.array(z.object({
    type: z.enum(['hs_code', 'cargo']),
    value: z.string(),
    alertFrequency: z.enum(['immediate', 'daily', 'weekly']),
  })).min(1),
});

// Use with useFieldArray for dynamic lists
const { fields, append, remove } = useFieldArray({
  control,
  name: 'targets',
});
```

## Data Visualization with Tremor React

### Chart Component Patterns

**Trade Statistics Visualization:**
```typescript
// ğŸ¯ Recommended: Separate data transformation from visualization
const TradeStatisticsChart = ({ hsCode }: { hsCode: string }) => {
  const { data: statistics } = useQuery({
    queryKey: ['tradeStatistics', hsCode],
    queryFn: () => comtradeApi.getStatistics(hsCode),
  });

  const chartData = useMemo(() => {
    if (!statistics) return [];
    
    return statistics.monthlyData.map(item => ({
      month: format(new Date(item.date), 'MMM yyyy'),
      ìˆ˜ì¶œì•¡: item.exportValue / 1000000, // Convert to millions
      ìˆ˜ì…ì•¡: item.importValue / 1000000,
      ê±°ë˜ëŸ‰: item.volume,
    }));
  }, [statistics]);

  if (!chartData.length) return <div>ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤</div>;

  return (
    <div className="space-y-6">
      <AreaChart
        data={chartData}
        index="month"
        categories={['ìˆ˜ì¶œì•¡', 'ìˆ˜ì…ì•¡']}
        colors={['blue', 'green']}
        valueFormatter={(value) => `${value}M`}
        yAxisLabel="ê¸ˆì•¡ (ë°±ë§Œ ë‹¬ëŸ¬)"
        className="h-72"
      />
      
      <BarChart
        data={chartData}
        index="month"
        categories={['ê±°ë˜ëŸ‰']}
        colors={['slate']}
        valueFormatter={(value) => `${value.toLocaleString()}í†¤`}
        yAxisLabel="ê±°ë˜ëŸ‰ (í†¤)"
        className="h-64"
      />
    </div>
  );
};
```

**Responsive Chart Patterns:**
```typescript
// ğŸ¯ Consider: Responsive breakpoints for chart layouts
const HSCodeDashboard = () => {
  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <Card>
        <CardHeader>
          <CardTitle>ì›”ë³„ ìˆ˜ì¶œì… ì¶”ì´</CardTitle>
        </CardHeader>
        <CardContent>
          <LineChart
            data={monthlyData}
            index="month" 
            categories={['export', 'import']}
            colors={['blue', 'red']}
            className="h-64 sm:h-72"
            showLegend={true}
            showTooltip={true}
          />
        </CardContent>
      </Card>
      
      <Card>
        <CardHeader>
          <CardTitle>ì£¼ìš” ê±°ë˜êµ­</CardTitle>
        </CardHeader>
        <CardContent>
          <DonutChart
            data={countryData}
            category="value"
            index="country"
            colors={['blue', 'cyan', 'indigo', 'violet']}
            className="h-64"
            showLabel={true}
          />
        </CardContent>
      </Card>
    </div>
  );
};
```

## Toast Notifications with Sonner

### Notification Patterns

**Global Toast Management:**
```typescript
// ğŸ¯ Recommended: Consistent toast patterns across app
import { toast } from 'sonner';

// Success patterns
const handleSuccessfulBookmark = (itemName: string) => {
  toast.success('ë¶ë§ˆí¬ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤', {
    description: `${itemName}ì„(ë¥¼) ëª¨ë‹ˆí„°ë§ ëª©ë¡ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤`,
    action: {
      label: 'ë³´ê¸°',
      onClick: () => navigate({ to: '/dashboard' }),
    },
  });
};

// Error patterns
const handleAnalysisError = (error: Error) => {
  toast.error('ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', {
    description: error.message,
    action: {
      label: 'ë‹¤ì‹œ ì‹œë„',
      onClick: () => retryAnalysis(),
    },
  });
};

// Loading patterns
const handleLongRunningAnalysis = () => {
  const loadingToast = toast.loading('HS Code ë¶„ì„ ì¤‘...', {
    description: 'ë©€í‹°ìŠ¤í… ë¶„ì„ì„ ì§„í–‰í•˜ê³  ìˆìŠµë‹ˆë‹¤',
  });

  // Update when complete
  analysisPromise
    .then((result) => {
      toast.success('ë¶„ì„ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤', { 
        id: loadingToast,
        description: `${result.hsCode} ë¶„ë¥˜ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”`,
      });
    })
    .catch((error) => {
      toast.error('ë¶„ì„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', { 
        id: loadingToast,
        description: error.message,
      });
    });
};
```

**Integration with Mutations:**
```typescript
// ğŸ¯ Consider: Automatic toast notifications with TanStack Query
const bookmarkMutation = useMutation({
  mutationFn: (item: BookmarkItem) => api.addBookmark(item),
  onSuccess: (data) => {
    toast.success('ë¶ë§ˆí¬ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤');
    queryClient.invalidateQueries({ queryKey: ['bookmarks'] });
  },
  onError: (error) => {
    toast.error('ë¶ë§ˆí¬ ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', {
      description: error.message,
    });
  },
});

// Custom hook for common patterns
const useBookmarkActions = () => {
  const queryClient = useQueryClient();
  
  const addBookmark = useMutation({
    mutationFn: api.addBookmark,
    onMutate: async (newBookmark) => {
      // Optimistic update
      const previousBookmarks = queryClient.getQueryData(['bookmarks']);
      queryClient.setQueryData(['bookmarks'], (old: BookmarkItem[]) => 
        [...(old || []), { ...newBookmark, id: 'temp-' + Date.now() }]
      );
      
      toast.promise(
        Promise.resolve(),
        {
          loading: 'ë¶ë§ˆí¬ ì¶”ê°€ ì¤‘...',
          success: 'ë¶ë§ˆí¬ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤',
          error: 'ë¶ë§ˆí¬ ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤',
        }
      );
      
      return { previousBookmarks };
    },
    onError: (error, variables, context) => {
      // Rollback on error
      queryClient.setQueryData(['bookmarks'], context?.previousBookmarks);
    },
  });
  
  return { addBookmark };
};
```

### TypeScript Patterns
Use `type` keyword instead of `interface`:

```typescript
// âœ… Preferred approach
type UserProfile = {
  id: number;
  email: string;
  preferences: UserPreferences;
};

type ApiResponse<T> = {
  success: boolean;
  data: T | null;
  message: string;
};

// âŒ Avoid interface declarations
interface UserProfile { // Don't use this
  id: number;
}
```

## Korean Development Standards

### Comment Style (Korean)
Use nominal form endings for Korean comments:

```typescript
// âœ… Correct Korean comment style
// ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ í•¨ìˆ˜
const fetchUserInfo = async (userId: string) => {
  // API í˜¸ì¶œ ë° ì‘ë‹µ ì²˜ë¦¬
  return await api.get(`/users/${userId}`);
};

// ìƒíƒœ ë³€ê²½ ê°ì§€ ë¡œì§
useEffect(() => {
  // ëª¨ë‹ˆí„°ë§ ëŒ€ìƒ ì—…ë°ì´íŠ¸ í™•ì¸
}, [monitoringTargets]);

// âŒ Avoid polite speech or non-nominal endings
// ì‚¬ìš©ì ì •ë³´ë¥¼ ì¡°íšŒí•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤ (Wrong)
// ë°ì´í„°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤ (Wrong)
```

### Error Messages & UI Text
All user-facing text in Korean:

```typescript
const ERROR_MESSAGES = {
  NETWORK_ERROR: 'ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë„¤íŠ¸ì›Œí¬ ìƒíƒœë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”.',
  INVALID_HS_CODE: 'HS Code í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.',
  ANALYSIS_FAILED: 'HS Code ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.',
} as const;
```

## Performance Monitoring

### React DevTools Integration
```typescript
// âœ… Performance debugging approach
useEffect(() => {
  if (process.env.NODE_ENV === 'development') {
    console.log('Component rendered:', { props, state });
  }
}, [props, state]);

// âœ… Profiler for production insights
const ProfiledComponent = React.memo(MyComponent);
```

### Avoiding Common Pitfalls

**Stale Closures:**
```typescript
// âŒ Stale closure problem
const [count, setCount] = useState(0);

useEffect(() => {
  const timer = setInterval(() => {
    setCount(count + 1); // Always uses initial count value
  }, 1000);
  return () => clearInterval(timer);
}, []); // Empty dependency array causes stale closure

// âœ… Correct approach with functional update
useEffect(() => {
  const timer = setInterval(() => {
    setCount(prev => prev + 1); // Uses current value
  }, 1000);
  return () => clearInterval(timer);
}, []);
```

**Object Dependencies:**
```typescript
// âŒ Object recreation on every render
const MyComponent = ({ config }) => {
  useEffect(() => {
    apiCall(config);
  }, [config]); // Runs on every render if config is recreated
};

// âœ… Memoize object references
const MyComponent = ({ rawConfig }) => {
  const config = useMemo(() => ({
    ...rawConfig,
    timestamp: Date.now()
  }), [rawConfig]);
  
  useEffect(() => {
    apiCall(config);
  }, [config]);
};
```

## Future-Proofing for React Compiler

### Preparing for Automatic Optimization
Write clean, predictable code that React Compiler can optimize:

```typescript
// âœ… Compiler-friendly patterns
const Component = ({ items }) => {
  // Simple, pure computations
  const sortedItems = items.sort((a, b) => a.name.localeCompare(b.name));
  
  // Clear data flow
  const handleClick = (item) => {
    onItemClick(item);
  };
  
  return (
    <div>
      {sortedItems.map(item => 
        <Item key={item.id} data={item} onClick={handleClick} />
      )}
    </div>
  );
};

// âœ… Avoid complex patterns that might confuse compiler
// Keep side effects in useEffect
// Use clear dependency relationships
// Minimize object mutations
```

## Integration with Project Architecture

### API Layer Compatibility
Structure components to work with TanStack Query + API abstraction:

```typescript
// âœ… Component ready for backend integration with TanStack Query
const HSCodeAnalysis = ({ query }: { query: string }) => {
  // Server state managed by TanStack Query
  const { 
    data: analysis, 
    isLoading, 
    error,
    refetch 
  } = useQuery({
    queryKey: ['hsCodeAnalysis', query],
    queryFn: () => claudeApi.analyzeHSCode(query), // API abstraction layer
    enabled: !!query,
    staleTime: 5 * 60 * 1000, // Cache for 5 minutes
    retry: 3,
  });

  // Client state for UI
  const [selectedTab, setSelectedTab] = useState('basic');

  // Side effects (not data fetching)
  useEffect(() => {
    if (analysis) {
      // Analytics tracking, notifications, etc.
      analytics.track('hs_code_analyzed', { code: analysis.hsCode });
    }
  }, [analysis]);

  if (isLoading) return <AnalysisSpinner />;
  if (error) return <ErrorDisplay error={error} onRetry={refetch} />;
  
  return (
    <AnalysisResults 
      analysis={analysis} 
      selectedTab={selectedTab}
      onTabChange={setSelectedTab}
    />
  );
};

// âœ… Custom hook pattern for reusable queries
const useHSCodeAnalysis = (query: string) => {
  return useQuery({
    queryKey: ['hsCodeAnalysis', query],
    queryFn: () => claudeApi.analyzeHSCode(query),
    enabled: !!query,
    staleTime: 5 * 60 * 1000,
  });
};
```

## Testing with Vitest & Testing Library

### Component Testing Patterns

**Setup and Configuration:**
```typescript
// vitest.config.ts recommended setup
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    globals: true,
  },
});

// src/test/setup.ts
import '@testing-library/jest-dom';
import { cleanup } from '@testing-library/react';
import { afterEach, vi } from 'vitest';

afterEach(() => {
  cleanup();
});

// Mock Sonner toast
vi.mock('sonner', () => ({
  toast: {
    success: vi.fn(),
    error: vi.fn(),
    loading: vi.fn(),
    promise: vi.fn(),
  },
}));
```

**TanStack Query Testing:**
```typescript
// ğŸ¯ Recommended: Test utility for query setup
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { render, screen, waitFor } from '@testing-library/react';
import { describe, it, expect, beforeEach, vi } from 'vitest';

const createTestQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: { retry: false },
    mutations: { retry: false },
  },
});

const createTestWrapper = (queryClient: QueryClient) => {
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('HSCodeAnalysis Component', () => {
  let queryClient: QueryClient;

  beforeEach(() => {
    queryClient = createTestQueryClient();
    vi.clearAllMocks();
  });

  it('should display loading state initially', () => {
    render(
      <HSCodeAnalysis query="test query" />,
      { wrapper: createTestWrapper(queryClient) }
    );
    
    expect(screen.getByTestId('analysis-spinner')).toBeInTheDocument();
  });

  it('should handle successful analysis', async () => {
    const mockAnalysis = {
      hsCode: '1234567890',
      description: 'Test product',
      confidence: 0.95,
    };

    // Mock API response
    vi.mocked(claudeApi.analyzeHSCode).mockResolvedValue(mockAnalysis);

    render(
      <HSCodeAnalysis query="test product" />,
      { wrapper: createTestWrapper(queryClient) }
    );

    await waitFor(() => {
      expect(screen.getByText('1234567890')).toBeInTheDocument();
      expect(screen.getByText('Test product')).toBeInTheDocument();
    });
  });
});
```

**Zustand Store Testing:**
```typescript
// ğŸ¯ Consider: Testing store logic separately
import { act, renderHook } from '@testing-library/react';
import { describe, it, expect, beforeEach } from 'vitest';

describe('useBookmarkStore', () => {
  beforeEach(() => {
    // Reset store state
    useBookmarkStore.setState({ 
      selectedFilters: [],
      sortOrder: 'recent'
    });
  });

  it('should update filters correctly', () => {
    const { result } = renderHook(() => useBookmarkStore());

    act(() => {
      result.current.setFilters(['electronics', 'export']);
    });

    expect(result.current.selectedFilters).toEqual(['electronics', 'export']);
  });

  it('should handle sort order changes', () => {
    const { result } = renderHook(() => useBookmarkStore());

    act(() => {
      result.current.setSortOrder('alphabetical');
    });

    expect(result.current.sortOrder).toBe('alphabetical');
  });
});
```

**Form Testing with React Hook Form:**
```typescript
// ğŸ¯ Recommended: Test form validation and submission
import { fireEvent, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

describe('HSCodeSearchForm', () => {
  it('should validate required fields', async () => {
    const user = userEvent.setup();
    render(<HSCodeSearchForm />);

    const submitButton = screen.getByRole('button', { name: /hs code ë¶„ì„/i });
    
    await user.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText('ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”')).toBeInTheDocument();
    });
  });

  it('should submit form with valid data', async () => {
    const user = userEvent.setup();
    const mockMutate = vi.fn();
    
    // Mock the mutation
    vi.mocked(useMutation).mockReturnValue({
      mutate: mockMutate,
      isPending: false,
    } as any);

    render(<HSCodeSearchForm />);

    const queryInput = screen.getByLabelText(/ìƒí’ˆëª… ë˜ëŠ” ì„¤ëª…/i);
    const submitButton = screen.getByRole('button', { name: /hs code ë¶„ì„/i });

    await user.type(queryInput, 'iPhone 15');
    await user.click(submitButton);

    expect(mockMutate).toHaveBeenCalledWith({
      query: 'iPhone 15',
      category: 'all',
    });
  });
});
```

**Integration Testing Patterns:**
```typescript
// ğŸ¯ Consider: End-to-end workflows
describe('HS Code Analysis Workflow', () => {
  it('should complete full analysis workflow', async () => {
    const user = userEvent.setup();
    const queryClient = createTestQueryClient();

    // Mock API responses
    vi.mocked(claudeApi.analyzeHSCode).mockResolvedValue({
      sessionId: 'test-session',
      status: 'processing',
    });

    render(<App />, { wrapper: createTestWrapper(queryClient) });

    // Navigate to search page
    await user.click(screen.getByText('HS Code ë¶„ì„'));

    // Fill and submit form
    const searchInput = screen.getByPlaceholderText('ì˜ˆ: ì•„ì´í° 15');
    await user.type(searchInput, 'iPhone 15');
    await user.click(screen.getByRole('button', { name: /ë¶„ì„/i }));

    // Verify navigation and loading state
    await waitFor(() => {
      expect(screen.getByText('ë¶„ì„ ì¤‘...')).toBeInTheDocument();
    });

    // Mock completion
    queryClient.setQueryData(['analysisSession', 'test-session'], {
      status: 'completed',
      result: { hsCode: '8517.12.00', description: 'Smartphones' },
    });

    // Verify results
    await waitFor(() => {
      expect(screen.getByText('8517.12.00')).toBeInTheDocument();
    });
  });
});
```

---

**Remember:** These patterns leverage TanStack Query v5.8+ for server state management while preparing for React 19 features. Separate server state (TanStack Query) from client state (useState + useEffect). As React Compiler becomes available, many memoization concerns will be handled automatically, but clean architectural separation remains essential.